# -*- coding: utf-8 -*-
"""Chapter_08.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2008/Chapter_08.ipynb

# 8 Control flow

# 8.1 The if-elif-else statement
"""

# you can change the value of guess to test how the if statement behaves
guess = 4
target = 7

if guess < target:
  print("Low")
elif guess == target:
  print("Correct!")
else:
  print("High")

"""# 8.2 Structural pattern matching with match"""

# change the value of x to experiment with the match statement
x = 5
match x:
  case "A":
    print("A")
  case str():
    print("some other string")
  case 0:
    print("Zero")
  case 1 | 2 | 3:
    print(f"value {x} in range")
  case int():
    print(f"The integer {x}")
  case _:
    print("Neither string nor int")

"""# 8.3 The while loop"""

response = ""
while response != "Q":
  response = input("Q to quit, B to break")
  if response == "B":
    break
else:
  print("no break")

"""# 8.4 The for loop"""

x = [1.0, 2.0, 3.0, 0.0, -1.0]
for n in x:
    if n == 0.0:
      print("skipping 0.0")
      continue
    elif n < 0.0:
      print("no negative numbers!")
      break
    print(1 / n)
else:
  print("Loop completed normally")

"""## 8.4.1 The range function"""

x = [1, 3, -7, 4, 9, -5, 4]
for i in range(len(x)):
    if x[i] < 0:
        print("Found a negative number at index ", i)

"""## 8.4.2 Controlling range with starting and stepping values"""

list(range(3, 7))        #A

list(range(2, 10))       #A

list(range(5, 3))

list(range(0, 10, 2))

list(range(5, 0, -1))

"""## 8.4.3 Using break and continue in for loops

## 8.4.4 The for loop and tuple unpacking
"""

somelist = [(1, 2), (3, 7), (9, 5)]
result = 0
for t in somelist:
    result = result + (t[0] * t[1])

somelist = [(1, 2), (3, 7), (9, 5)]
result = 0

for x, y in somelist:
    result = result + (x * y)

"""## 8.4.5 The enumerate function"""

x = [1, 3, -7, 4, 9, -5, 4]
for i, n in enumerate(x):             #A
    if n < 0:                                #B
        print("Found a negative number at index ", i)   #C

"""## 8.4.6 The zip function"""

x = [1, 2, 3, 4]
y = ['a', 'b', 'c']         #A
z = zip(x, y)
list(z)

"""### Try This: Looping and if statements
Suppose that you have a list `x = [1, 3, 5, 0, -1, 3, -2]`, and you need to remove all negative numbers from that list. Write the code to do this.

How would you count the total number of negative numbers in a list `y = [[1, -1, 0], [2, 5, -9], [-2, -3, 0]]`?

What code would you use to print "very low" if the value of x is below -5, "low" if it's from -5 up to 0, "neutral" if it's equal to 0, "high" if it'' greater than 0 up to 5, and "very high" if it's greater than 5?

Suppose that you have a list `x = [1, 3, 5, 0, -1, 3, -2]`, and you need to remove all negative numbers from that list. Write the code to do this.
"""

x = [1, 3, 5, 0, -1, 3, -2]
for i in x:
    if i < 0:
        x.remove(i)
print(x)

"""How would you count the total number of negative numbers in a list `y = [[1, -1, 0], [2, 5, -9], [-2, -3, 0]]`?"""

count = 0
y = [[1, -1, 0], [2, 5, -9], [-2, -3, 0]]
for row in y:
    for col in row:
        if col < 0:
            count += 1
print(count)

"""What code would you use to print "very low" if the value of x is below -5, "low" if it's from -5 up to 0, "neutral" if it's equal to 0, "high" if it'' greater than 0 up to 5, and "very high" if it's greater than 5?

"""

if x < -5:
    print("very low")
elif x <= 0:
    print("low")
elif x == 0:   # could be 'elif not x:' but the point here is comparison to 0
    print("neutral")
elif x <= 5:
    print("high")
else:
    print("very high")

"""# 8.5 List, set, and dictionary comprehensions"""

x = [1, 2, 3, 4]
x_squared = []
for item in x:
    x_squared.append(item * item)

x_squared

x = [1, 2, 3, 4]
x_squared = [item * item for item in x]
x_squared

x = [1, 2, 3, 4]
x_squared = [item * item for item in x if item > 2]

x_squared

x = [1, 2, 3, 4]
x_squared_dict = {item: item * item for item in x}
x_squared_dict

"""## 8.5.1 Generator expressions"""

x = [1, 2, 3, 4]
x_squared = (item * item for item in x)
x_squared

for square in x_squared:
    print(square,)

"""### Try This: Comprehensions
What list comprehension would you use to process the list x so that all negative values are removed?

Create a generator that returns only odd numbers from 1 to 100. (Hint: A number is odd if there is a remainder if divided by 2; use % 2 to get the remainder of division by 2.)

Write the code to create a dictionary of the numbers and their cubes from 11 through 15.

What list comprehension would you use to process the list x so that all negative values are removed?
"""

x = [1, 3, 5, 0, -1, 3, -2]
new_x = [i for i in x if i >= 0]
print(new_x)

"""Create a generator that returns only odd numbers from 1 to 100. (Hint: A number is odd if there is a remainder if divided by 2; use % 2 to get the remainder of division by 2.)"""

odd_100 = (x for x in range(100) if x % 2)
for i in odd_100:
    print(i))

"""Write the code to create a dictionary of the numbers and their cubes from 11 through 15."""

cubes = {x: x**3 for x in range(11, 16)}
print(cubes)

"""# 8.6 Statements, blocks, and indentation"""

x = 1; y = 0; z = 0
if x > 0: y = 1; z = 10
else: y = -1

print(x, y, z)

x = 1
 x = 2

>>> x = 1
... if x == 1:
...    y = 2
...    if y > 0:
...        z = 2
...        v = 0
...
>>> x = 2

x = 1
if x == 1:
    y = 2
  z = 2

print('string1', 'string2', 'string3' \
   , 'string4', 'string5')

x = 100 + 200 + 300 \
   + 400 + 500
x

v = [100, 300, 500, 700, 900,
   1100, 1300]
v

max(1000, 300, 500,
       800, 1200)

x = (100 + 200 + 300
         + 400 + 500)
x

"strings separated by whitespace "    \
   '''are automatically'''  ' concatenated'

x = 1
if x > 0:
       string1 = "this string broken by a backslash will end up \
               with the indentation tabs in it"

repr(string1)

if x > 0:
       string1 = "this can be easily avoided by splitting the " \
           "string in this way"

string1

"""# 8.7 Boolean values and expressions

## 8.7.2 Comparison and Boolean operators
"""

[2] and [3, 4]

[] and 5

[2] or [3, 4]

[] or 5

x = [0]
y = [x, 1]
x is y[0]          #A

x = [0]            #B
x is y[0]

x == y[0]

"""### Quick Check: Booleans and truthiness
Decide whether the following statements are true or false: `1`, `0`, `-1`, `[0]`, `1 and 0`, `1 > 0 or []`.

* `1` ->: `True`.
* `0` ->: `False`.
* `-1`: `True`.
* `[0]`: `True`; it's a list containing one item.
* `1 and 0`: False.
* `1 > 0 or []`: True.

# 8.8 Writing a simple program to analyze a text file

**Execute the cell below to create the file `word_count.tst`**
"""

# create file word_count.tst"
open("word_count.tst", "w").write("""Python provides a complete set of control flow elements,
including while and for loops, and conditionals.
Python uses the level of indentation to group blocks
of code with control elements.""")

#!/usr/bin/env python3

''' Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
'''

infile = open('word_count.tst')                   #A

lines = infile.read().split("\n")          #B

line_count = len(lines)               #C

word_count = 0     #D
char_count = 0     #D

for line in lines:                      #E

    words = line.split()                #F
    word_count += len(words)

    char_count += len(line)             #G

print("File has {0} lines, {1} words, {2} characters".format           #H
                             (line_count, word_count, char_count))     #H

"""### Lab 8: Refactor word_count
Rewrite the word-count program from section 8.7 to make it shorter. You may want to look at the string and list operations already discussed, as well as think about different ways to organize the code. You may also want to make the program smarter so that only alphabetic strings (not symbols or punctuation) count as words.
"""

# Create your solution in this cell

# Author's solution

# File: word_count_refactored.py
""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""

# initialze counts
line_count = 0
word_count = 0
char_count = 0

# open the file
with  open('word_count.tst') as infile:
    for line in infile:
        line_count += 1
        char_count += len(line)
        word_count += len(line.split())

# print the answers using the format() method
print("File has {0} lines, {1} words, {2} characters".format(line_count,
                                               word_count, char_count))

Generated by Colaboratory

# prompt: Refactor the word-count program above to make it shorter.
#         You may want to look at the string and list, as well as
#         think about  different ways to organize the code.

#!/usr/bin/env python3

''' Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
'''

with open('word_count.tst') as infile:
    lines = infile.read().split("\n")
    words = [word for line in lines for word in line.split()]
    chars = sum(len(line) for line in lines)

print("File has {0} lines, {1} words, {2} characters".format(len(lines), len(words), chars))

# Generated by Copilot
#!/usr/bin/env python3

""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""

with open('word_count.tst') as infile:
    lines = infile.readlines()

line_count = len(lines)
word_count = sum(len(line.split()) for line in lines)
char_count = sum(len(line) for line in lines)

print(f"File has {line_count} lines, {word_count} words, {char_count} characters")

